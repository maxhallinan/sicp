# 1.2

> To become experts, we must learn to visualize the processes generated by 
> various types of procedures.
>
> Page 31

> A procedure is a pattern for the _local evolution_ of a computational process.
> 
> Page 31

## 1.2.1

```
factorial n = n * (n - 1)
```

**Linear recursive process**

A recursive _procedure_ and recursive _processes_ are not the same thing.
A procedure is recursive when it is defined in terms of itself.
A process is recursive when the evaluation builds up a chain of sub-expressions 
whose evaluation is deferred until the chain is complete.

This iterative process has linear (`O(n)`) time and space complexity.

```lisp
(define (factorial x) 
  (if (= x 1) 
    x
    (* x (factorial (- x 1)))))
```

```lisp
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

**Linear iterative process**

> In general, an iterative process is one whose state can be summarized by a 
> fixed number of _state variables_, together with a fixed rule that describes
> how the state variables should be updated as the process moves from state to 
> state, and an (optional) end test that specifies the conditions under which
> the process should terminate.
>
> Page 34

A linear iterative process uses stateful variables instead of the deferred 
evaluation of sub-expressions to build up the computation.
The state is updated at each step of the computation. 
There is less memory overhead because the intermediate steps are evaluated 
immediately.

This interative process has linear time (`O(n)`) and constant space (`O(1)`) 
complexity.

```lisp
(define (factorial x) 
  (define (iter counter product) 
    (if (= counter x) 
      product
      (iter (+ counter 1) (* product counter))))
  (iter 1 x))
```

```lisp
(factorial 6)
(iter (+ 1 1) (* 6 1))
(iter 2 6)
(iter (+ 2 1) (* 6 2))
(iter 3 12)
(iter (+ 3 1) (* 12 3))
(iter 4 36)
(iter (+ 4 1) (* 36 4))
(iter 5 144)
(iter (+ 5 1) (* 144 5))
(iter 6 720)
720
```
