# 1.2

> To become experts, we must learn to visualize the processes generated by 
> various types of procedures.
>
> Page 31

> A procedure is a pattern for the _local evolution_ of a computational process.
> 
> Page 31

## 1.2.1

```
factorial n = n * (n - 1)
```

**Linear recursive process**

A recursive _procedure_ and recursive _processes_ are not the same thing.
A procedure is recursive when it is defined in terms of itself.
A process is recursive when the evaluation builds up a chain of sub-expressions 
whose evaluation is deferred until the chain is complete.

This iterative process has linear (`O(n)`) time and space complexity.

```lisp
(define (factorial x) 
  (if (= x 1) 
    x
    (* x (factorial (- x 1)))))
```

```lisp
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

**Linear iterative process**

> In general, an iterative process is one whose state can be summarized by a 
> fixed number of _state variables_, together with a fixed rule that describes
> how the state variables should be updated as the process moves from state to 
> state, and an (optional) end test that specifies the conditions under which
> the process should terminate.
>
> Page 34

A linear iterative process uses stateful variables instead of the deferred 
evaluation of sub-expressions to build up the computation.
The state is updated at each step of the computation. 
There is less memory overhead because the intermediate steps are evaluated 
immediately.

This interative process has linear time (`O(n)`) and constant space (`O(1)`) 
complexity.

```lisp
(define (factorial x) 
  (define (iter counter product) 
    (if (= counter x) 
      product
      (iter (+ counter 1) (* product counter))))
  (iter 1 x))
```

```lisp
(factorial 6)
(iter (+ 1 1) (* 6 1))
(iter 2 6)
(iter (+ 2 1) (* 6 2))
(iter 3 12)
(iter (+ 3 1) (* 12 3))
(iter 4 36)
(iter (+ 4 1) (* 36 4))
(iter 5 144)
(iter (+ 5 1) (* 144 5))
(iter 6 720)
720
```

## 1.2.2 Tree Recursion

A recursive function of a tree often involves redundant computation.
When two branches of a tree are identical, an un-optimized tree recursion will 
make the same reduction twice.

## 1.2.3 Orders of Growth

"Order of growth" is a rough measure of the resources required by a process as
the inputs grow.

`R(n)` is the amount of resources required for a problem of size `n`.

Examples of `n`:

- number of digits accuracy required
- number of internal storage registers used
- number of cpu cycles

`R(n)` grows on the order of `O(f(n))` if there are positive constants `x` and
`y` independent of `n`, such that: `xf(n) <= R(n) <= yf(n)` for any sufficiently
large value of `n`.

- `O(1)`: constant growth, not affected by variance in the size of the input
- `O(n)`: linear growth, proportional to the size of the input
- `O(n^2)`: exponential growth

### O(log n)

`log(n)` grows linearly with increases in order of magnitude.

```
6 = log(1000000)
5 = log(100000)
4 = log(10000)
3 = log(1000)
2 = log(100)
1 = log(10)
```

## Exercise 1.19

**`T`**

```
T = a <- a + b, b <- 
```

Observe that applying `T` over and over again `n` times, starting with 1 and 0,
produces the pair `Fib(n+1)` and `Fib(n)`.

```
T^1 = 1 + 0, 1
    = 1, 1
T^2 = 1 + 1, 1
    = 2, 1
T^3 = 2 + 1, 2
    = 3, 2
T^4 = 3 + 2, 3
    = 5, 3
```

**`Tpq`**


```
p = 0
q = 1
Tpq = a <- bq + aq + ap, b <- bp + aq
```

`Tpq^n` and `T^n` give the same result:

```
Tpq^1 = (0 * 1) + (1 * 1) + (1 * 0), (0 * 1) + (1 * 1)
      = 0 + 1 + 0, 0 + 1
      = 1, 1
Tpq^2 = (1 * 1) + (1 * 1) + (1 * 0), (1 * 0) + (1 * 1)
      = 1 + 1 + 0, 0 + 1
      = 2, 1
Tpq^3 = (1 * 1) + (2 * 1) + (2 * 0), (1 * 0) + (2 * 1)
      = 1 + 2 + 0, 0 + 2
      = 3, 2
Tpq^4 = (2 * 1) + (3 * 1) + (3 * 0), (2 * 0) + (3 * 1)
      = 2 + 3 + 0, 0 + 3
      = 5, 3
Tpq^5 = (3 * 1) + (5 * 1) + (5 * 0), (3 * 0) + (5 * 1)
      = 3 + 5 + 0, 0 + 5
      = 8, 5
Tpq^6 = (5 * 1) + (8 * 1) + (8 * 0), (5 * 0) + (8 * 1)
      = 5 + 8 + 0, 0 + 8
      = 13, 8
```

**Tq'p'**

`Tq'p'` gives the same result in 1 step that `Tqp` does in 2 steps.

`p'` and `q'` are defined in terms of `p` and `q`.

```
a = 1
b = 0
p = 0
q = 1

Tpq = a <- bq + aq + ap, b <- bp + aq

Tp'q'^1 = (0 * q) + (1 * q) + (1 * p), (0 * p) + (1 * q)
        = (0 * 1) + (1 * 1) + (1 * 1), (0 * 1) + (1 * 1)
        = 0 + 1 + 1, 0 + 1
        = 2, 1

Tp'q'^2 = a <- bq + aq + ap, b <- bp + aq
        = (0 * 3) + (1 * 3) + (1 * 2), (0 * 2) + (1 * 3)
        = 0 + 3 + 2, 0 + 3
        = 5, 3
```

It seems like the `p` increases by `Fib(n)` and `q` increases by `Fib(n+1)`.
But when I try this, the formula doesn't work.

The closest I've gotten is:

```lisp
(define (fib-iter a b x y count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   y
                   (fib-iter 1 0 0 1 (square y))
                   (/ count 2)))
        (else (fib-iter (+ (* b y) (* a y) (* a x))
                        (+ (* b x) (* a y))
                        x
                        y
                        (- count 1)))))
```

This calculates the first 3 places in the sequence correctly.

This one gets some of them right:

```scheme
(define (fib-iter a b x y count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (fib-iter 1 0 0 1 (square y))
                   (+ x y)
                   (/ count 2)))
        (else (fib-iter (+ (* b y) (* a y) (* a x))
                        (+ (* b x) (* a y))
                        x
                        y
                        (- count 1)))))

```

I could also see `(square (fib-iter 1 0 0 1 y))` making sense.

This gets some of them right:

```scheme
(define (fib-iter a b x y count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (square (fib-iter 1 0 0 1 y))
                   (+ x 1)
                   (/ count 2)))
        (else (fib-iter (+ (* b y) (* a y) (* a x))
                        (+ (* b x) (* a y))
                        x
                        y
                        (- count 1)))))
```

## 1.2.6 Testing for Primality

### Method 1: Search for divisors

If `n` is not prime, it must have a divisor less than or equal to the square 
root of `n`.
This method tries each number between 1 and the square root of `n` to see if 
that number is a divisor of `n`.
Thus, the time complexity is O(square-root(n)).

```scheme
(define (prime? n) 
  (= n (smallest-divisor n)))

(define (smallest-divisor n) 
  (find-divisor n 2))

(define (find-divisor n test-divisor) 
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b) 
  (= (remainder b a) 0))
```

### Method 2: The Fermat test

#### Fermat's Little Theorem

> If `n` is a prime number and `a` is any positive integer less than `n`, then
> `a` raised to the nth power is congruent to `a` modulo `n`.

Two numbers are "congruent modulo n" if they both have the same remainder 
divided by `n`.

Fermat test:

- Given a number `n` 
- Pick a random number `a < n` 
- Compute the remainder `a^n modulo n`
- If `(a^n modulo n) != a`, n is not prime
- If it is `a`, pick another random number and test with the same method
- Confidence that `n` is prime grows with the number of tests

Compute the exponential of a number modulo another number:

```scheme
; run the fermat test a given number of times
(define (fast-prime? n times) 
  (cond ((= times 0) true) 
        ((fermat-test n) (fast-prime? n (- times 1))) 
        (else false)))

(define (fermat-test n) 
  (define (try-it a) 
    (= (expmod a n n) a)) 
  (try-it (+ 1 (random (- n 1)))))

(define (expmod base exp m) 
  (cond ((= exp 0) 1) 
        ((even? exp) 
          (remainder (square (expmod base (/ exp 2) m)) m)) 
        (else 
          (remainder (* base (expmod base (- exp 1))) m))))
```


#### Fermat's Little Theorem 2

`n` is prime when:

```
0 < a < n
a^n-1 ≡ 1 (mod n)
```

This notation means that `a^n-1 mod n = 1 mod n`.

#### Miller-Rabin Test

Pick a random number `a`, where `0 < a < n`.

```
0 < a < n
a^n-1 ≡ 
```
